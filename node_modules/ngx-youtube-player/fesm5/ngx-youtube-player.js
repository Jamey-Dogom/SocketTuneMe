import { __assign } from 'tslib';
import { ReplaySubject } from 'rxjs';
import { Injectable, NgZone, ChangeDetectionStrategy, Component, ElementRef, EventEmitter, Input, Output, Renderer2, NgModule, defineInjectable, inject } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function win() {
    return window;
}
/**
 * @return {?}
 */
function YouTubeRef() {
    return win()['YT'];
}
/**
 * @return {?}
 */
function YouTubePlayerRef() {
    return YouTubeRef().Player;
}
/** @type {?} */
var defaultSizes = {
    height: 270,
    width: 367
};
var YoutubePlayerService = /** @class */ (function () {
    function YoutubePlayerService(zone) {
        this.zone = zone;
        this.ytApiLoaded = false;
        this.api = new ReplaySubject(1);
        this.createApi();
    }
    /**
     * @param {?} options
     * @return {?}
     */
    YoutubePlayerService.prototype.loadPlayerApi = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        /** @type {?} */
        var doc = win().document;
        if (!this.ytApiLoaded) {
            this.ytApiLoaded = true;
            /** @type {?} */
            var playerApiScript = doc.createElement('script');
            playerApiScript.type = 'text/javascript';
            playerApiScript.src = options.protocol + "://www.youtube.com/iframe_api";
            doc.body.appendChild(playerApiScript);
        }
    };
    /**
     * @param {?} elementId
     * @param {?} outputs
     * @param {?} sizes
     * @param {?=} videoId
     * @param {?=} playerVars
     * @return {?}
     */
    YoutubePlayerService.prototype.setupPlayer = /**
     * @param {?} elementId
     * @param {?} outputs
     * @param {?} sizes
     * @param {?=} videoId
     * @param {?=} playerVars
     * @return {?}
     */
    function (elementId, outputs, sizes, videoId, playerVars) {
        var _this = this;
        if (videoId === void 0) { videoId = ''; }
        /** @type {?} */
        var createPlayer = (/**
         * @return {?}
         */
        function () {
            if (YouTubePlayerRef) {
                _this.createPlayer(elementId, outputs, sizes, videoId, playerVars);
            }
        });
        this.api.subscribe(createPlayer);
    };
    /**
     * @param {?} player
     * @return {?}
     */
    YoutubePlayerService.prototype.play = /**
     * @param {?} player
     * @return {?}
     */
    function (player) {
        player.playVideo();
    };
    /**
     * @param {?} player
     * @return {?}
     */
    YoutubePlayerService.prototype.pause = /**
     * @param {?} player
     * @return {?}
     */
    function (player) {
        player.pauseVideo();
    };
    /**
     * @param {?} media
     * @param {?} player
     * @return {?}
     */
    YoutubePlayerService.prototype.playVideo = /**
     * @param {?} media
     * @param {?} player
     * @return {?}
     */
    function (media, player) {
        /** @type {?} */
        var id = media.id.videoId ? media.id.videoId : media.id;
        player.loadVideoById(id);
        this.play(player);
    };
    /**
     * @param {?} player
     * @return {?}
     */
    YoutubePlayerService.prototype.isPlaying = /**
     * @param {?} player
     * @return {?}
     */
    function (player) {
        // because YT is not loaded yet 1 is used - YT.PlayerState.PLAYING
        /** @type {?} */
        var isPlayerReady = player && player.getPlayerState;
        /** @type {?} */
        var playerState = isPlayerReady ? player.getPlayerState() : {};
        /** @type {?} */
        var isPlayerPlaying = isPlayerReady
            ? playerState !== YouTubeRef().PlayerState.ENDED &&
                playerState !== YouTubeRef().PlayerState.PAUSED
            : false;
        return isPlayerPlaying;
    };
    /**
     * @param {?} elementId
     * @param {?} outputs
     * @param {?} sizes
     * @param {?=} videoId
     * @param {?=} playerVars
     * @return {?}
     */
    YoutubePlayerService.prototype.createPlayer = /**
     * @param {?} elementId
     * @param {?} outputs
     * @param {?} sizes
     * @param {?=} videoId
     * @param {?=} playerVars
     * @return {?}
     */
    function (elementId, outputs, sizes, videoId, playerVars) {
        var _this = this;
        if (videoId === void 0) { videoId = ''; }
        if (playerVars === void 0) { playerVars = {}; }
        /** @type {?} */
        var playerSize = {
            height: sizes.height || defaultSizes.height,
            width: sizes.width || defaultSizes.width
        };
        /** @type {?} */
        var ytPlayer = YouTubePlayerRef();
        return new ytPlayer(elementId, __assign({}, playerSize, { events: {
                onReady: (/**
                 * @param {?} ev
                 * @return {?}
                 */
                function (ev) {
                    _this.zone.run((/**
                     * @return {?}
                     */
                    function () { return outputs.ready && outputs.ready.next(ev.target); }));
                }),
                onStateChange: (/**
                 * @param {?} ev
                 * @return {?}
                 */
                function (ev) {
                    _this.zone.run((/**
                     * @return {?}
                     */
                    function () { return outputs.change && outputs.change.next(ev); }));
                })
            }, playerVars: playerVars,
            videoId: videoId }));
    };
    /**
     * @param {?} player
     * @param {?} isFullScreen
     * @return {?}
     */
    YoutubePlayerService.prototype.toggleFullScreen = /**
     * @param {?} player
     * @param {?} isFullScreen
     * @return {?}
     */
    function (player, isFullScreen) {
        var height = defaultSizes.height, width = defaultSizes.width;
        if (!isFullScreen) {
            height = window.innerHeight;
            width = window.innerWidth;
        }
        player.setSize(width, height);
    };
    // adpoted from uid
    // adpoted from uid
    /**
     * @return {?}
     */
    YoutubePlayerService.prototype.generateUniqueId = 
    // adpoted from uid
    /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var len = 7;
        return Math.random()
            .toString(35)
            .substr(2, len);
    };
    /**
     * @private
     * @return {?}
     */
    YoutubePlayerService.prototype.createApi = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var onYouTubeIframeAPIReady = (/**
         * @return {?}
         */
        function () {
            if (win()) {
                _this.api.next(YouTubeRef());
            }
        });
        win()['onYouTubeIframeAPIReady'] = onYouTubeIframeAPIReady;
    };
    YoutubePlayerService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    YoutubePlayerService.ctorParameters = function () { return [
        { type: NgZone }
    ]; };
    /** @nocollapse */ YoutubePlayerService.ngInjectableDef = defineInjectable({ factory: function YoutubePlayerService_Factory() { return new YoutubePlayerService(inject(NgZone)); }, token: YoutubePlayerService, providedIn: "root" });
    return YoutubePlayerService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var YoutubePlayerComponent = /** @class */ (function () {
    function YoutubePlayerComponent(playerService, elementRef, renderer) {
        this.playerService = playerService;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.videoId = '';
        this.height = defaultSizes.height;
        this.width = defaultSizes.width;
        /**
         * \@description sets the protocol by the navigator object
         * if there is no window, it sets a default http protocol
         * unless the protocol is set from outside
         */
        this.protocol = this.getProtocol();
        this.playerVars = {};
        // player created and initialized - sends instance of the player
        this.ready = new EventEmitter();
        // state change: send the YT event with its state
        this.change = new EventEmitter();
    }
    /**
     * @return {?}
     */
    YoutubePlayerComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var htmlId = this.playerService.generateUniqueId();
        /** @type {?} */
        var playerSize = { height: this.height, width: this.width };
        /** @type {?} */
        var container = this.renderer.selectRootElement('#yt-player-ngx-component');
        this.renderer.setAttribute(container, 'id', htmlId);
        this.playerService.loadPlayerApi({
            protocol: this.protocol
        });
        this.playerService.setupPlayer(htmlId, {
            change: this.change,
            ready: this.ready
        }, playerSize, this.videoId, this.playerVars);
    };
    /**
     * @return {?}
     */
    YoutubePlayerComponent.prototype.getProtocol = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var hasWindow = window && window.location;
        /** @type {?} */
        var protocol = hasWindow
            ? window.location.protocol.replace(':', '')
            : 'http';
        return protocol;
    };
    YoutubePlayerComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'youtube-player',
                    template: "\n    <div id=\"yt-player-ngx-component\"></div>\n  "
                }] }
    ];
    /** @nocollapse */
    YoutubePlayerComponent.ctorParameters = function () { return [
        { type: YoutubePlayerService },
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    YoutubePlayerComponent.propDecorators = {
        videoId: [{ type: Input }],
        height: [{ type: Input }],
        width: [{ type: Input }],
        protocol: [{ type: Input }],
        playerVars: [{ type: Input }],
        ready: [{ type: Output }],
        change: [{ type: Output }]
    };
    return YoutubePlayerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxYoutubePlayerModule = /** @class */ (function () {
    function NgxYoutubePlayerModule() {
    }
    /**
     * @return {?}
     */
    NgxYoutubePlayerModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: NgxYoutubePlayerModule,
            providers: [YoutubePlayerService]
        };
    };
    NgxYoutubePlayerModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [YoutubePlayerComponent],
                    imports: [],
                    providers: [YoutubePlayerService],
                    exports: [YoutubePlayerComponent]
                },] }
    ];
    return NgxYoutubePlayerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { win, YouTubeRef, YouTubePlayerRef, defaultSizes, YoutubePlayerService, YoutubePlayerComponent, NgxYoutubePlayerModule };

//# sourceMappingURL=ngx-youtube-player.js.map