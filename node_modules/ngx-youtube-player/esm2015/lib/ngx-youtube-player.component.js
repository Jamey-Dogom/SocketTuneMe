/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, Input, Output, Renderer2 } from '@angular/core';
import { YoutubePlayerService, defaultSizes } from './ngx-youtube-player.service';
export class YoutubePlayerComponent {
    /**
     * @param {?} playerService
     * @param {?} elementRef
     * @param {?} renderer
     */
    constructor(playerService, elementRef, renderer) {
        this.playerService = playerService;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.videoId = '';
        this.height = defaultSizes.height;
        this.width = defaultSizes.width;
        /**
         * \@description sets the protocol by the navigator object
         * if there is no window, it sets a default http protocol
         * unless the protocol is set from outside
         */
        this.protocol = this.getProtocol();
        this.playerVars = {};
        // player created and initialized - sends instance of the player
        this.ready = new EventEmitter();
        // state change: send the YT event with its state
        this.change = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        /** @type {?} */
        const htmlId = this.playerService.generateUniqueId();
        /** @type {?} */
        const playerSize = { height: this.height, width: this.width };
        /** @type {?} */
        const container = this.renderer.selectRootElement('#yt-player-ngx-component');
        this.renderer.setAttribute(container, 'id', htmlId);
        this.playerService.loadPlayerApi({
            protocol: this.protocol
        });
        this.playerService.setupPlayer(htmlId, {
            change: this.change,
            ready: this.ready
        }, playerSize, this.videoId, this.playerVars);
    }
    /**
     * @return {?}
     */
    getProtocol() {
        /** @type {?} */
        const hasWindow = window && window.location;
        /** @type {?} */
        const protocol = hasWindow
            ? window.location.protocol.replace(':', '')
            : 'http';
        return protocol;
    }
}
YoutubePlayerComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'youtube-player',
                template: `
    <div id="yt-player-ngx-component"></div>
  `
            }] }
];
/** @nocollapse */
YoutubePlayerComponent.ctorParameters = () => [
    { type: YoutubePlayerService },
    { type: ElementRef },
    { type: Renderer2 }
];
YoutubePlayerComponent.propDecorators = {
    videoId: [{ type: Input }],
    height: [{ type: Input }],
    width: [{ type: Input }],
    protocol: [{ type: Input }],
    playerVars: [{ type: Input }],
    ready: [{ type: Output }],
    change: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    YoutubePlayerComponent.prototype.videoId;
    /** @type {?} */
    YoutubePlayerComponent.prototype.height;
    /** @type {?} */
    YoutubePlayerComponent.prototype.width;
    /**
     * \@description sets the protocol by the navigator object
     * if there is no window, it sets a default http protocol
     * unless the protocol is set from outside
     * @type {?}
     */
    YoutubePlayerComponent.prototype.protocol;
    /** @type {?} */
    YoutubePlayerComponent.prototype.playerVars;
    /** @type {?} */
    YoutubePlayerComponent.prototype.ready;
    /** @type {?} */
    YoutubePlayerComponent.prototype.change;
    /** @type {?} */
    YoutubePlayerComponent.prototype.playerService;
    /**
     * @type {?}
     * @private
     */
    YoutubePlayerComponent.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    YoutubePlayerComponent.prototype.renderer;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LXlvdXR1YmUtcGxheWVyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC15b3V0dWJlLXBsYXllci8iLCJzb3VyY2VzIjpbImxpYi9uZ3gteW91dHViZS1wbGF5ZXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBRUwsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLEtBQUssRUFFTCxNQUFNLEVBQ04sU0FBUyxFQUVWLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFDTCxvQkFBb0IsRUFDcEIsWUFBWSxFQUNiLE1BQU0sOEJBQThCLENBQUM7QUFTdEMsTUFBTSxPQUFPLHNCQUFzQjs7Ozs7O0lBaUJqQyxZQUNTLGFBQW1DLEVBQ2xDLFVBQXNCLEVBQ3RCLFFBQW1CO1FBRnBCLGtCQUFhLEdBQWIsYUFBYSxDQUFzQjtRQUNsQyxlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQ3RCLGFBQVEsR0FBUixRQUFRLENBQVc7UUFuQnBCLFlBQU8sR0FBRyxFQUFFLENBQUM7UUFDYixXQUFNLEdBQUcsWUFBWSxDQUFDLE1BQU0sQ0FBQztRQUM3QixVQUFLLEdBQUcsWUFBWSxDQUFDLEtBQUssQ0FBQzs7Ozs7O1FBTTNCLGFBQVEsR0FBVyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDdEMsZUFBVSxHQUFrQixFQUFFLENBQUM7O1FBRzlCLFVBQUssR0FBRyxJQUFJLFlBQVksRUFBYSxDQUFDOztRQUV0QyxXQUFNLEdBQUcsSUFBSSxZQUFZLEVBQWtCLENBQUM7SUFNbkQsQ0FBQzs7OztJQUVKLGtCQUFrQjs7Y0FDVixNQUFNLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsRUFBRTs7Y0FDOUMsVUFBVSxHQUFHLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUU7O2NBQ3ZELFNBQVMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLGlCQUFpQixDQUMvQywwQkFBMEIsQ0FDM0I7UUFDRCxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxTQUFTLEVBQUUsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3BELElBQUksQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDO1lBQy9CLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUTtTQUN4QixDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FDNUIsTUFBTSxFQUNOO1lBQ0UsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO1lBQ25CLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSztTQUNsQixFQUNELFVBQVUsRUFDVixJQUFJLENBQUMsT0FBTyxFQUNaLElBQUksQ0FBQyxVQUFVLENBQ2hCLENBQUM7SUFDSixDQUFDOzs7O0lBRUQsV0FBVzs7Y0FDSCxTQUFTLEdBQUcsTUFBTSxJQUFJLE1BQU0sQ0FBQyxRQUFROztjQUNyQyxRQUFRLEdBQUcsU0FBUztZQUN4QixDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUM7WUFDM0MsQ0FBQyxDQUFDLE1BQU07UUFDVixPQUFPLFFBQVEsQ0FBQztJQUNsQixDQUFDOzs7WUExREYsU0FBUyxTQUFDO2dCQUNULGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO2dCQUMvQyxRQUFRLEVBQUUsZ0JBQWdCO2dCQUMxQixRQUFRLEVBQUU7O0dBRVQ7YUFDRjs7OztZQVZDLG9CQUFvQjtZQVRwQixVQUFVO1lBS1YsU0FBUzs7O3NCQWdCUixLQUFLO3FCQUNMLEtBQUs7b0JBQ0wsS0FBSzt1QkFNTCxLQUFLO3lCQUNMLEtBQUs7b0JBR0wsTUFBTTtxQkFFTixNQUFNOzs7O0lBZFAseUNBQXNCOztJQUN0Qix3Q0FBc0M7O0lBQ3RDLHVDQUFvQzs7Ozs7OztJQU1wQywwQ0FBK0M7O0lBQy9DLDRDQUF3Qzs7SUFHeEMsdUNBQWdEOztJQUVoRCx3Q0FBc0Q7O0lBR3BELCtDQUEwQzs7Ozs7SUFDMUMsNENBQThCOzs7OztJQUM5QiwwQ0FBMkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIE91dHB1dCxcbiAgUmVuZGVyZXIyLFxuICBTaW1wbGVDaGFuZ2VzXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgWW91dHViZVBsYXllclNlcnZpY2UsXG4gIGRlZmF1bHRTaXplc1xufSBmcm9tICcuL25neC15b3V0dWJlLXBsYXllci5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBzZWxlY3RvcjogJ3lvdXR1YmUtcGxheWVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IGlkPVwieXQtcGxheWVyLW5neC1jb21wb25lbnRcIj48L2Rpdj5cbiAgYFxufSlcbmV4cG9ydCBjbGFzcyBZb3V0dWJlUGxheWVyQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCB7XG4gIEBJbnB1dCgpIHZpZGVvSWQgPSAnJztcbiAgQElucHV0KCkgaGVpZ2h0ID0gZGVmYXVsdFNpemVzLmhlaWdodDtcbiAgQElucHV0KCkgd2lkdGggPSBkZWZhdWx0U2l6ZXMud2lkdGg7XG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gc2V0cyB0aGUgcHJvdG9jb2wgYnkgdGhlIG5hdmlnYXRvciBvYmplY3RcbiAgICogaWYgdGhlcmUgaXMgbm8gd2luZG93LCBpdCBzZXRzIGEgZGVmYXVsdCBodHRwIHByb3RvY29sXG4gICAqIHVubGVzcyB0aGUgcHJvdG9jb2wgaXMgc2V0IGZyb20gb3V0c2lkZVxuICAgKi9cbiAgQElucHV0KCkgcHJvdG9jb2w6IHN0cmluZyA9IHRoaXMuZ2V0UHJvdG9jb2woKTtcbiAgQElucHV0KCkgcGxheWVyVmFyczogWVQuUGxheWVyVmFycyA9IHt9O1xuXG4gIC8vIHBsYXllciBjcmVhdGVkIGFuZCBpbml0aWFsaXplZCAtIHNlbmRzIGluc3RhbmNlIG9mIHRoZSBwbGF5ZXJcbiAgQE91dHB1dCgpIHJlYWR5ID0gbmV3IEV2ZW50RW1pdHRlcjxZVC5QbGF5ZXI+KCk7XG4gIC8vIHN0YXRlIGNoYW5nZTogc2VuZCB0aGUgWVQgZXZlbnQgd2l0aCBpdHMgc3RhdGVcbiAgQE91dHB1dCgpIGNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8WVQuUGxheWVyRXZlbnQ+KCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHBsYXllclNlcnZpY2U6IFlvdXR1YmVQbGF5ZXJTZXJ2aWNlLFxuICAgIHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjJcbiAgKSB7fVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICBjb25zdCBodG1sSWQgPSB0aGlzLnBsYXllclNlcnZpY2UuZ2VuZXJhdGVVbmlxdWVJZCgpO1xuICAgIGNvbnN0IHBsYXllclNpemUgPSB7IGhlaWdodDogdGhpcy5oZWlnaHQsIHdpZHRoOiB0aGlzLndpZHRoIH07XG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5yZW5kZXJlci5zZWxlY3RSb290RWxlbWVudChcbiAgICAgICcjeXQtcGxheWVyLW5neC1jb21wb25lbnQnXG4gICAgKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZShjb250YWluZXIsICdpZCcsIGh0bWxJZCk7XG4gICAgdGhpcy5wbGF5ZXJTZXJ2aWNlLmxvYWRQbGF5ZXJBcGkoe1xuICAgICAgcHJvdG9jb2w6IHRoaXMucHJvdG9jb2xcbiAgICB9KTtcbiAgICB0aGlzLnBsYXllclNlcnZpY2Uuc2V0dXBQbGF5ZXIoXG4gICAgICBodG1sSWQsXG4gICAgICB7XG4gICAgICAgIGNoYW5nZTogdGhpcy5jaGFuZ2UsXG4gICAgICAgIHJlYWR5OiB0aGlzLnJlYWR5XG4gICAgICB9LFxuICAgICAgcGxheWVyU2l6ZSxcbiAgICAgIHRoaXMudmlkZW9JZCxcbiAgICAgIHRoaXMucGxheWVyVmFyc1xuICAgICk7XG4gIH1cblxuICBnZXRQcm90b2NvbCgpIHtcbiAgICBjb25zdCBoYXNXaW5kb3cgPSB3aW5kb3cgJiYgd2luZG93LmxvY2F0aW9uO1xuICAgIGNvbnN0IHByb3RvY29sID0gaGFzV2luZG93XG4gICAgICA/IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbC5yZXBsYWNlKCc6JywgJycpXG4gICAgICA6ICdodHRwJztcbiAgICByZXR1cm4gcHJvdG9jb2w7XG4gIH1cbn1cbiJdfQ==