/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, Input, Output, Renderer2 } from '@angular/core';
import { YoutubePlayerService, defaultSizes } from './ngx-youtube-player.service';
var YoutubePlayerComponent = /** @class */ (function () {
    function YoutubePlayerComponent(playerService, elementRef, renderer) {
        this.playerService = playerService;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.videoId = '';
        this.height = defaultSizes.height;
        this.width = defaultSizes.width;
        /**
         * \@description sets the protocol by the navigator object
         * if there is no window, it sets a default http protocol
         * unless the protocol is set from outside
         */
        this.protocol = this.getProtocol();
        this.playerVars = {};
        // player created and initialized - sends instance of the player
        this.ready = new EventEmitter();
        // state change: send the YT event with its state
        this.change = new EventEmitter();
    }
    /**
     * @return {?}
     */
    YoutubePlayerComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var htmlId = this.playerService.generateUniqueId();
        /** @type {?} */
        var playerSize = { height: this.height, width: this.width };
        /** @type {?} */
        var container = this.renderer.selectRootElement('#yt-player-ngx-component');
        this.renderer.setAttribute(container, 'id', htmlId);
        this.playerService.loadPlayerApi({
            protocol: this.protocol
        });
        this.playerService.setupPlayer(htmlId, {
            change: this.change,
            ready: this.ready
        }, playerSize, this.videoId, this.playerVars);
    };
    /**
     * @return {?}
     */
    YoutubePlayerComponent.prototype.getProtocol = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var hasWindow = window && window.location;
        /** @type {?} */
        var protocol = hasWindow
            ? window.location.protocol.replace(':', '')
            : 'http';
        return protocol;
    };
    YoutubePlayerComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'youtube-player',
                    template: "\n    <div id=\"yt-player-ngx-component\"></div>\n  "
                }] }
    ];
    /** @nocollapse */
    YoutubePlayerComponent.ctorParameters = function () { return [
        { type: YoutubePlayerService },
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    YoutubePlayerComponent.propDecorators = {
        videoId: [{ type: Input }],
        height: [{ type: Input }],
        width: [{ type: Input }],
        protocol: [{ type: Input }],
        playerVars: [{ type: Input }],
        ready: [{ type: Output }],
        change: [{ type: Output }]
    };
    return YoutubePlayerComponent;
}());
export { YoutubePlayerComponent };
if (false) {
    /** @type {?} */
    YoutubePlayerComponent.prototype.videoId;
    /** @type {?} */
    YoutubePlayerComponent.prototype.height;
    /** @type {?} */
    YoutubePlayerComponent.prototype.width;
    /**
     * \@description sets the protocol by the navigator object
     * if there is no window, it sets a default http protocol
     * unless the protocol is set from outside
     * @type {?}
     */
    YoutubePlayerComponent.prototype.protocol;
    /** @type {?} */
    YoutubePlayerComponent.prototype.playerVars;
    /** @type {?} */
    YoutubePlayerComponent.prototype.ready;
    /** @type {?} */
    YoutubePlayerComponent.prototype.change;
    /** @type {?} */
    YoutubePlayerComponent.prototype.playerService;
    /**
     * @type {?}
     * @private
     */
    YoutubePlayerComponent.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    YoutubePlayerComponent.prototype.renderer;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LXlvdXR1YmUtcGxheWVyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC15b3V0dWJlLXBsYXllci8iLCJzb3VyY2VzIjpbImxpYi9uZ3gteW91dHViZS1wbGF5ZXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBRUwsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLEtBQUssRUFFTCxNQUFNLEVBQ04sU0FBUyxFQUVWLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFDTCxvQkFBb0IsRUFDcEIsWUFBWSxFQUNiLE1BQU0sOEJBQThCLENBQUM7QUFFdEM7SUF3QkUsZ0NBQ1MsYUFBbUMsRUFDbEMsVUFBc0IsRUFDdEIsUUFBbUI7UUFGcEIsa0JBQWEsR0FBYixhQUFhLENBQXNCO1FBQ2xDLGVBQVUsR0FBVixVQUFVLENBQVk7UUFDdEIsYUFBUSxHQUFSLFFBQVEsQ0FBVztRQW5CcEIsWUFBTyxHQUFHLEVBQUUsQ0FBQztRQUNiLFdBQU0sR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDO1FBQzdCLFVBQUssR0FBRyxZQUFZLENBQUMsS0FBSyxDQUFDOzs7Ozs7UUFNM0IsYUFBUSxHQUFXLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUN0QyxlQUFVLEdBQWtCLEVBQUUsQ0FBQzs7UUFHOUIsVUFBSyxHQUFHLElBQUksWUFBWSxFQUFhLENBQUM7O1FBRXRDLFdBQU0sR0FBRyxJQUFJLFlBQVksRUFBa0IsQ0FBQztJQU1uRCxDQUFDOzs7O0lBRUosbURBQWtCOzs7SUFBbEI7O1lBQ1EsTUFBTSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLEVBQUU7O1lBQzlDLFVBQVUsR0FBRyxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFOztZQUN2RCxTQUFTLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FDL0MsMEJBQTBCLENBQzNCO1FBQ0QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztRQUNwRCxJQUFJLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQztZQUMvQixRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVE7U0FDeEIsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQzVCLE1BQU0sRUFDTjtZQUNFLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTTtZQUNuQixLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7U0FDbEIsRUFDRCxVQUFVLEVBQ1YsSUFBSSxDQUFDLE9BQU8sRUFDWixJQUFJLENBQUMsVUFBVSxDQUNoQixDQUFDO0lBQ0osQ0FBQzs7OztJQUVELDRDQUFXOzs7SUFBWDs7WUFDUSxTQUFTLEdBQUcsTUFBTSxJQUFJLE1BQU0sQ0FBQyxRQUFROztZQUNyQyxRQUFRLEdBQUcsU0FBUztZQUN4QixDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUM7WUFDM0MsQ0FBQyxDQUFDLE1BQU07UUFDVixPQUFPLFFBQVEsQ0FBQztJQUNsQixDQUFDOztnQkExREYsU0FBUyxTQUFDO29CQUNULGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO29CQUMvQyxRQUFRLEVBQUUsZ0JBQWdCO29CQUMxQixRQUFRLEVBQUUsc0RBRVQ7aUJBQ0Y7Ozs7Z0JBVkMsb0JBQW9CO2dCQVRwQixVQUFVO2dCQUtWLFNBQVM7OzswQkFnQlIsS0FBSzt5QkFDTCxLQUFLO3dCQUNMLEtBQUs7MkJBTUwsS0FBSzs2QkFDTCxLQUFLO3dCQUdMLE1BQU07eUJBRU4sTUFBTTs7SUFxQ1QsNkJBQUM7Q0FBQSxBQTNERCxJQTJEQztTQXBEWSxzQkFBc0I7OztJQUNqQyx5Q0FBc0I7O0lBQ3RCLHdDQUFzQzs7SUFDdEMsdUNBQW9DOzs7Ozs7O0lBTXBDLDBDQUErQzs7SUFDL0MsNENBQXdDOztJQUd4Qyx1Q0FBZ0Q7O0lBRWhELHdDQUFzRDs7SUFHcEQsK0NBQTBDOzs7OztJQUMxQyw0Q0FBOEI7Ozs7O0lBQzlCLDBDQUEyQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgT3V0cHV0LFxuICBSZW5kZXJlcjIsXG4gIFNpbXBsZUNoYW5nZXNcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBZb3V0dWJlUGxheWVyU2VydmljZSxcbiAgZGVmYXVsdFNpemVzXG59IGZyb20gJy4vbmd4LXlvdXR1YmUtcGxheWVyLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHNlbGVjdG9yOiAneW91dHViZS1wbGF5ZXInLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgaWQ9XCJ5dC1wbGF5ZXItbmd4LWNvbXBvbmVudFwiPjwvZGl2PlxuICBgXG59KVxuZXhwb3J0IGNsYXNzIFlvdXR1YmVQbGF5ZXJDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcbiAgQElucHV0KCkgdmlkZW9JZCA9ICcnO1xuICBASW5wdXQoKSBoZWlnaHQgPSBkZWZhdWx0U2l6ZXMuaGVpZ2h0O1xuICBASW5wdXQoKSB3aWR0aCA9IGRlZmF1bHRTaXplcy53aWR0aDtcbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBzZXRzIHRoZSBwcm90b2NvbCBieSB0aGUgbmF2aWdhdG9yIG9iamVjdFxuICAgKiBpZiB0aGVyZSBpcyBubyB3aW5kb3csIGl0IHNldHMgYSBkZWZhdWx0IGh0dHAgcHJvdG9jb2xcbiAgICogdW5sZXNzIHRoZSBwcm90b2NvbCBpcyBzZXQgZnJvbSBvdXRzaWRlXG4gICAqL1xuICBASW5wdXQoKSBwcm90b2NvbDogc3RyaW5nID0gdGhpcy5nZXRQcm90b2NvbCgpO1xuICBASW5wdXQoKSBwbGF5ZXJWYXJzOiBZVC5QbGF5ZXJWYXJzID0ge307XG5cbiAgLy8gcGxheWVyIGNyZWF0ZWQgYW5kIGluaXRpYWxpemVkIC0gc2VuZHMgaW5zdGFuY2Ugb2YgdGhlIHBsYXllclxuICBAT3V0cHV0KCkgcmVhZHkgPSBuZXcgRXZlbnRFbWl0dGVyPFlULlBsYXllcj4oKTtcbiAgLy8gc3RhdGUgY2hhbmdlOiBzZW5kIHRoZSBZVCBldmVudCB3aXRoIGl0cyBzdGF0ZVxuICBAT3V0cHV0KCkgY2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxZVC5QbGF5ZXJFdmVudD4oKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcGxheWVyU2VydmljZTogWW91dHViZVBsYXllclNlcnZpY2UsXG4gICAgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMlxuICApIHt9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIGNvbnN0IGh0bWxJZCA9IHRoaXMucGxheWVyU2VydmljZS5nZW5lcmF0ZVVuaXF1ZUlkKCk7XG4gICAgY29uc3QgcGxheWVyU2l6ZSA9IHsgaGVpZ2h0OiB0aGlzLmhlaWdodCwgd2lkdGg6IHRoaXMud2lkdGggfTtcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLnJlbmRlcmVyLnNlbGVjdFJvb3RFbGVtZW50KFxuICAgICAgJyN5dC1wbGF5ZXItbmd4LWNvbXBvbmVudCdcbiAgICApO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKGNvbnRhaW5lciwgJ2lkJywgaHRtbElkKTtcbiAgICB0aGlzLnBsYXllclNlcnZpY2UubG9hZFBsYXllckFwaSh7XG4gICAgICBwcm90b2NvbDogdGhpcy5wcm90b2NvbFxuICAgIH0pO1xuICAgIHRoaXMucGxheWVyU2VydmljZS5zZXR1cFBsYXllcihcbiAgICAgIGh0bWxJZCxcbiAgICAgIHtcbiAgICAgICAgY2hhbmdlOiB0aGlzLmNoYW5nZSxcbiAgICAgICAgcmVhZHk6IHRoaXMucmVhZHlcbiAgICAgIH0sXG4gICAgICBwbGF5ZXJTaXplLFxuICAgICAgdGhpcy52aWRlb0lkLFxuICAgICAgdGhpcy5wbGF5ZXJWYXJzXG4gICAgKTtcbiAgfVxuXG4gIGdldFByb3RvY29sKCkge1xuICAgIGNvbnN0IGhhc1dpbmRvdyA9IHdpbmRvdyAmJiB3aW5kb3cubG9jYXRpb247XG4gICAgY29uc3QgcHJvdG9jb2wgPSBoYXNXaW5kb3dcbiAgICAgID8gd2luZG93LmxvY2F0aW9uLnByb3RvY29sLnJlcGxhY2UoJzonLCAnJylcbiAgICAgIDogJ2h0dHAnO1xuICAgIHJldHVybiBwcm90b2NvbDtcbiAgfVxufVxuIl19